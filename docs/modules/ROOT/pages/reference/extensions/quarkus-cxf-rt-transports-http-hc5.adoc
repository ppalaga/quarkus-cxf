// Do not edit directly!
// This file was generated by cq-maven-plugin:update-doc-page
[id="quarkus-cxf-rt-transports-http-hc5"]
= HTTP Async Transport
:linkattrs:
:cq-artifact-id: quarkus-cxf-rt-transports-http-hc5
:cq-group-id: io.quarkiverse.cxf
:cq-status: Experimental
:cq-deprecated: false
:cq-since: 1.1.0

ifeval::[{doc-show-badges} == true]
ðŸ§ªExperimental â€¢ Since 1.1.0
endif::[]

Implement async SOAP Clients using Apache HttpComponents HttpClient 5.

IMPORTANT: This extension is experimental, because there are https://github.com/quarkiverse/quarkus-cxf/issues/505[no tests covering it]. Contributions are welcome!


[id="quarkus-cxf-rt-transports-http-hc5-maven-coordinates"]
== Maven coordinates

Create https://{link-quarkus-code-generator}/?extension-search=quarkus-cxf-rt-transports-http-hc5[a new project using `quarkus-cxf-rt-transports-http-hc5` on {link-quarkus-code-generator}, window="_blank"]
or add these coordinates to your existing project:

[source,xml]
----
<dependency>
    <groupId>io.quarkiverse.cxf</groupId>
    <artifactId>quarkus-cxf-rt-transports-http-hc5</artifactId>
</dependency>
----
ifeval::[{doc-show-user-guide-link} == true]
TIP: Check the xref:user-guide/index.adoc[User guide] and especially its
      xref:user-guide/create-project.adoc#dependency-management[Dependency management] section
      for more information about writing applications with {quarkus-cxf-project-name}.
endif::[]

[id="quarkus-cxf-rt-transports-http-hc5-usage"]
== Usage

Once the `quarkus-cxf-rt-transports-http-hc5` dependency is available in the classpath,
CXF will use `HttpAsyncClient` for asynchronous calls and will continue using `HttpURLConnection` for synchronous calls.

NOTE: You can see more details about the CXF asynchronous client and how to tune it further in https://cxf.apache.org/docs/asynchronous-client-http-transport.html[CXF documentation].

[[async-uni]]
[id="extensions-quarkus-cxf-rt-transports-http-hc5-usage-asynchronous-clients-and-mutiny"]
=== Asynchronous Clients and Mutiny

Asynchronous client invocations require some additional methods in the service endpoint interface.
That code is not generated by default.

To enable it, you need to create a JAX-WS binding file with `enableAsyncMapping` set to `true`:

.binding.xml
[source,xml]
----
<bindings xmlns:xsd="http://www.w3.org/2001/XMLSchema"
          xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/"
          wsdlLocation="AffectedWSDL"
          xmlns="http://java.sun.com/xml/ns/jaxws">
  <bindings node="AffectedNode">
    <enableAsyncMapping>true</enableAsyncMapping>
  </bindings>
</bindings>
----

This file should then be passed to xref:user-guide/first-soap-client.adoc#wsdl2java[wsdl2java]
through its xref:reference/extensions/quarkus-cxf.adoc#quarkus-cxf_quarkus.cxf.codegen.wsdl2java.additional-params[additional-params] property:

.application.properties
[source,properties]
----
quarkus.cxf.java2ws.includes = HelloService.wsdl
quarkus.cxf.java2ws.foo-params.additional-params = -b,src/main/resources/binding.xml
----

Once the asynchronous stubs are available, it is possible to wrap a client call in `io.smallrye.mutiny.Uni` as shown below:

[source,java,subs="attributes"]
----
import {javaxOrJakartaPackagePrefix}.inject.Inject;
import io.smallrye.mutiny.Uni;
import io.quarkiverse.cxf.annotation.CXFClient;

class Client {

    @Inject @CXFClient
    CalculatorService calculator;

    public Uni<AddResponse> add(int a, int b) {
        return Uni.createFrom().future(() ->
                (Future<AddResponse>)calculatorSoap.addAsync(a, b, res -> {}));
    }
}
----

TIP: A sample application demonstrating this flow is available https://github.com/quarkiverse/quarkus-cxf/issues/4#issuecomment-1106487964[here].

