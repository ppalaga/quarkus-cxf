[[synchronous-vs-asynchronous-client]]
= Synchronous vs. asynchronous SOAP client

When calling a SOAP client synchronously, the service method does not return before the response from the remote service is completely received and parsed:

[source,java]
----
@CXFClient("hello")
HelloService hello;

void callHello() {
    // Synchronous CXF client call
    String result = hello.hello("Joe");
    Log.info(result);
}
----

When calling the client asynchronously, the service method may terminate before the response from the remote service was received.
The result is an instance of `jakarta.xml.ws.Response` extending `java.util.concurrent.Future`.
It represents the result of an asynchronous computation,
which may have completed already or will be completed in the future.

`java.util.concurrent.Future` can be transformed to https://smallrye.io/smallrye-mutiny/latest/[SmallRye Mutiny] `Uni` type
and further used as a return value of a https://quarkus.io/guides/rest#asyncreactive-support[reactive REST endpoint]:

[source,java]
----
import io.smallrye.mutiny.Uni;
import jakarta.xml.ws.Response;

@CXFClient("hello")
HelloService hello;

Uni<String> callHelloAsync() {
    // Asynchronous CXF client call returning jakarta.xml.ws.Response
    Response<HelloResponse> helloResponseFuture = hello.helloAsync("Joe");
    return Uni.createFrom()
            .future(helloResponseFuture)
            .map(HelloResponse::getReturn);
}
----

[NOTE]
====
The `java.util.concurrent.Future` interface has limited capabilities for reactive styles of programming.
Internally, the above `future(helloResponseFuture)` call polls on `Future.isDone()` on a worker thread to void blocking Vert.x Event Loop.
Therefore, the performance expectations should not be too high.
====

[[wsdl2java]]
[id="extensions-quarkus-cxf-rt-transports-http-hc5-usage-generate-async-methods"]
== Generate async methods

Asynchronous client invocations require some additional methods in the service endpoint interface.
That code is not generated by default.

To enable it, you need to create a JAX-WS binding file with `enableAsyncMapping` set to `true`:

[TIP]
====
The sample code snippets used in this section come from the
https://github.com/quarkiverse/quarkus-cxf/tree/main/integration-tests/hc5[HC5 integration test]
in the source tree of {quarkus-cxf-project-name}
====

.src/main/resources/wsdl/async-binding.xml
[source,xml]
----
include::example$hc5/async-binding.xml[]
----

This file should then be passed to xref:user-guide/contract-first-code-first/generate-java-from-wsdl.adoc[wsdl2java]
through its xref:reference/extensions/quarkus-cxf.adoc#quarkus-cxf_quarkus-cxf-codegen-wsdl2java-additional-params[additional-params] property:

.application.properties
[source,properties]
----
include::example$hc5/application.properties[tag=quarkus-cxf-rt-transports-http-hc5.usage.wsdl2java]
----

== Historical note

Since {quarkus-cxf-project-name} 3.17.0, the asynchronous mode is supported by `VertxHttpClientHTTPConduit` provided via the
`xref:reference/extensions/quarkus-cxf.adoc[io.quarkiverse.cxf:quarkus-cxf]` extension.

Before {quarkus-cxf-project-name} 3.17.0, the asynchronous use case was only supported via
`xref:reference/extensions/quarkus-cxf-rt-transports-http-hc5.adoc[io.quarkiverse.cxf:quarkus-cxf-rt-transports-http-hc5]`
which is now deprecated and scheduled for removal in {quarkus-cxf-project-name} 3.21.0.
