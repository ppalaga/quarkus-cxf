= Create a new project

include::../includes/attributes.adoc[]

== `client-endpoint-url` defaults

If you omit the `client-endpoint-url` property in `application.properties`,
the CXF Quarkus extension will assume that the service is published at `http://localhost:8080/\{service-path}`,
where `\{service-path}` is derived from

* Configuration property `quarkus.cxf.path` (if specified); and the
* SEIâ€™s class name in lower case

Given `quarkus.cxf.path=/ws`, the default effective `client-endpoint-url` of the `CalculatorService` would be
`http://localhost:8080/ws/org.jboss.eap.quickstarts.wscalculator.calculator.calculatorservice`.

If `quarkus.cxf.path` is not specified, the `client-endpoint-url` would be just
`http://localhost:8080/ws/org.jboss.eap.quickstarts.wscalculator.calculator.calculatorservice`.

== Configure multiple clients

In the example above, we configured just a single client called `myCalculator`.
Of course, you can configure multiple clients pointing at different URLs and/or implementing different SEIs using multiple identifiers:

.application.properties
[source,properties]
----
cxf.it.calculator.baseUri=http://localhost:8082
include::example$calculator-client/application.properties[tag=first-soap-client.adoc]

# another client
quarkus.cxf.client.anotherCalculator.wsdl=https://acme.com/ws/WeatherService?wsdl
quarkus.cxf.client.anotherCalculator.client-endpoint-url=https://acme.com/ws/WeatherService
quarkus.cxf.client.anotherCalculator.service-interface=org.jboss.eap.quickstarts.wscalculator.calculator.CalculatorService
----

[[basic-auth]]
== Basic Authentication

Basic authentication for clients is supported by default.
Just add the following properties to your `application.properties`:

[source,properties]
----
quarkus.cxf.client.myCalculator.username=user
quarkus.cxf.client.myCalculator.password=password
----

[[async-support]]
== Asynchronous Client HTTP Transport

By default, the CXF client uses `HttpURLConnection` to perform HTTP requests.

In order to have non-blocking (asynchronous) invocations you can add the  `quarkus-cxf-rt-transports-http-hc5` dependency to your project.  This module provides full support for native mode.

[source,xml,subs=attributes+]
----
<dependency>
    <groupId>io.quarkiverse.cxf</groupId>
    <artifactId>quarkus-cxf-rt-transports-http-hc5</artifactId>
</dependency>
----

Once the dependency is available in the classpath, CXF will use `HttpAsyncClient` for asynchronous calls and will continue using `HttpURLConnection` for synchronous calls.

NOTE: You can see more details about the CXF asynchronous client and how to tune it further at https://cxf.apache.org/docs/asynchronous-client-http-transport.html[this link].

[[async-uni]]
== Asynchronous Clients and Unis

Asynchronous client invocations require stub code (dedicated asynchronous methods defined on the service endpoint interface).
The stub code is not generated by default.

To switch on the asynchronous feature and generate the necessary stub code, you must use the JAX-WS `enableAsyncMapping` binding declaration.
A JAX-WS binding file can be created containing this customization, which can then be referenced in your `wsdl2java` code generation process.

Once the asynchronous stubs are available, it is possible to wrap a client call in a Uni as shown below:

[source,java]
----
    @Inject @CXFClient
    CalculatorSoap calculatorSoap;

    public Uni<AddResponse> addNumbers(Integer num1, Integer num2) {
        return Uni.createFrom().future(() ->
                (Future<AddResponse>)calculatorSoap.addAsync(num1, num2, res -> {}));
    }
----

NOTE: A sample application demonstrating this flow is provided https://github.com/quarkiverse/quarkus-cxf/issues/4#issuecomment-1106487964[here].

[[code-config]]
== Advanced Client Configurations

To globally configure all clients in your application, you can use the example snippet below to configure the
https://cxf.apache.org/docs/client-http-transport-including-ssl-support.html#ClientHTTPTransport(includingSSLsupport)-Usingjavacode[`HttpConduit`].
This allows you to set the `HTTPClientPolicy`, `AuthorizationPolicy`, `ProxyAuthorizationPolicy` or even `TLSClientParameters` for your clients.

[source,java]
----
void onStart(@Observes StartupEvent ev) {

     HTTPConduitConfigurer httpConduitConfigurer = new HTTPConduitConfigurer() {
         public void configure(String name, String address, HTTPConduit c) {
             AsyncHTTPConduit conduit = (AsyncHTTPConduit)c;
             // use setter to configure client
             conduit.getHttpAsyncClient().getCredentialsProvider().setCredentials( AuthScope.ANY,
              new NTCredentials( USER,PWD, "", DOM ) );
             conduit.getClient().setAllowChunking( false );
             conduit.getClient().setAutoRedirect( true );
         }
     };

     final Bus bus = BusFactory.getThreadDefaultBus();
     bus.setExtension(httpConduitConfigurer, HTTPConduitConfigurer.class);
}
----

To configure the `HttpConduit` for a single client in your application, use the example snippet below:

[source,java]
----
    @Inject
    @CXFClient
    SomePortType portType;

    @PostConstruct
    void configurePortType() throws NoSuchAlgorithmException, UnrecoverableKeyException, KeyStoreException {
        final var httpConduit = (HTTPConduit) ClientProxy.getClient(portType).getConduit();
        final var tlsClientParameters = Optional.ofNullable(httpConduit.getTlsClientParameters()).orElseGet(TLSClientParameters::new);
        tlsClientParameters.setCertAlias(config.clientCert().keyAlias());
        tlsClientParameters.setKeyManagers(clientKeyManagers);
        tlsClientParameters.setTrustManagers(clientTrustManagers);
        httpConduit.setTlsClientParameters(tlsClientParameters);
    }
----

[[pure-client]]
== Pure client applications

Quarkus batch (e.g. periodically scheduled), or command line applications, may do without an HTTP server.
Use the property below to prevent launching the HTTP server at startup:

[source,properties]
----
quarkus.http.host-enabled=false
----
